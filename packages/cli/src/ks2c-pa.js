#!/usr/bin/env node

// this script takes a file as input (defaults to kabelsalat.js)
// the file is expected to contain a kabelsalat patch
// the patch is used to generate a c file that plays the patch
// the c file uses portaudio, so it should work on all supported platforms

import fs from "node:fs/promises";
import * as core from "@kabelsalat/core/src/index.js";
import * as lib from "@kabelsalat/lib/src/index.js";
import { existsSync } from "node:fs";
import path from "node:path";

async function main() {
  let file = process.argv[2];
  if (!file) {
    file = "./kabelsalat.js";
    console.log(`no input file given -> using "${file}"`);
  }
  const fileExists = existsSync(file);

  if (!fileExists) {
    console.log(`file "${file}" not found.`);
    return;
  }

  const filePath = path.resolve(process.cwd(), file);
  const ksCode = await fs.readFile(filePath, { encoding: "utf8" });
  const ugenPath = path.resolve(process.cwd(), "./clib/ugens.c");
  const ugenCode = await fs.readFile(ugenPath, { encoding: "utf8" });
  Object.assign(globalThis, core);
  Object.assign(globalThis, lib);
  const node = core.evaluate(ksCode);
  const unit = node.compile({ lang: "c" });
  const cCode = ks2c(unit, ugenCode);
  const outFileName = file + "-pa.c";
  // console.log(cCode);
  try {
    await fs.writeFile(outFileName, cCode);

    console.log(`written ${outFileName}`);
  } catch (err) {
    console.log(`error writing ${outFileName}: ${err.message}`);
  }
}

main();

let ks2c = (
  unit,
  ugens
) => `// this file has been compiled from kabelsalat, using ks2c-pa
// to build it, you need portaudio on your system
// compile and run on OSX with:
// gcc kabelsalat.js-pa.c -o kabelsalat-pa -I/opt/homebrew/include -L/opt/homebrew/lib -lportaudio -lm && ./kabelsalat-pa
// this will spit out a self-contained ~34kB binary that plays the compiled kabelsalat patch

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <portaudio.h>

${ugens}

#define SAMPLE_RATE 44100     
#define FRAMES_PER_BUFFER 256
#define SAMPLE_TIME (1.0 / SAMPLE_RATE)

typedef struct
{
  double time;
  float* r;
  float* o;
  int osize;
  float* s;
  void** nodes; // wtf am i doing
} CallbackEnv;

static int DSPCallback(const void *inputBuffer, void *outputBuffer,
                            unsigned long framesPerBuffer,
                            const PaStreamCallbackTimeInfo *timeInfo,
                            PaStreamCallbackFlags statusFlags,
                            void *userData)
{
  CallbackEnv *env = (CallbackEnv *)userData;
  float *out = (float *)outputBuffer;

  void **nodes = env->nodes;

  float *o = env->o;
  float *r = env->r;
  float *s = env->s;
  

  for (unsigned long i = 0; i < framesPerBuffer; i++)
  {

    double time = env->time;
    memset(o, 0, env->osize); // reset outputs

// start of autogenerated callback
${unit.src}
// end of autogenerated callback

    float left = o[0];
    float right = o[1];

    *out++ = left*.3; 
    *out++ = right*.3;
    env->time += SAMPLE_TIME;
  }
  return paContinue;
}

int main()
{
  PaError err;
  PaStream *stream;


  float o[16] = {0}; // output registry
  float s[16] = {0}; // source registry

  // start of autogenerated init
float r[${unit.registers}] = {0}; // node registry
void *nodes[${unit.ugens.length}];
${unit.ugens
  .map((ugen, i) => `nodes[${i}] = ${ugen.type}_create();`)
  .join("\n")}

// end of autogenerated init

  CallbackEnv env;
  env.nodes = nodes;
  env.r = (float *)r;
  env.o = (float *)o;
  env.osize = sizeof(o);
  env.s = (float *)s;
  env.time = 0;

  err = Pa_Initialize();
  if (err != paNoError)
  {
    fprintf(stderr, "PortAudio error: %s\\n", Pa_GetErrorText(err));
    return 1;
  }

  err = Pa_OpenDefaultStream(&stream,
                             0,         // input channels
                             2,         // output channels
                             paFloat32,
                             SAMPLE_RATE,
                             FRAMES_PER_BUFFER,
                             DSPCallback,
                             &env);
  if (err != paNoError)
  {
    fprintf(stderr, "PortAudio error: %s\\n", Pa_GetErrorText(err));
    Pa_Terminate();
    return 1;
  }

  err = Pa_StartStream(stream);
  if (err != paNoError)
  {
    fprintf(stderr, "PortAudio error: %s\\n", Pa_GetErrorText(err));
    Pa_Terminate();
    return 1;
  }

  printf("Playing kabelsalat patch. Press Enter to stop...\\n");
  getchar();

  err = Pa_StopStream(stream);
  if (err != paNoError)
  {
    fprintf(stderr, "PortAudio error: %s\\n", Pa_GetErrorText(err));
  }

  err = Pa_CloseStream(stream);
  if (err != paNoError)
  {
    fprintf(stderr, "PortAudio error: %s\\n", Pa_GetErrorText(err));
  }

  Pa_Terminate();

  printf("playback stopped.\\n");
  return 0;
}
`;
